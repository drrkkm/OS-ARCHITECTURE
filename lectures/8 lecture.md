# Файловая система Unix

## Логические разделы физического носителя информации
- Физический носитель информации (диск, лента) в ОС представляется в виде `partitions` – т.н. разделов или логических дисков
- Физический диск делится на несколько разделов, но и несколько дисков можно объединить в один раздел (raid-массив)
- Разделы упорядочены линейно (без вложенностей и т.п.)
- В рамках каждого раздела – своя файловая система
- Применяемые структуры разделов на диске
  1. MBR (Master Boot Record) – традиционная, 4 раздела максимум, 2Тб на раздел
  2. GPT (GUID Partition Table) – современная (2000+)

## Необходимость partitions
1. Несколько операционных систем на одном физическом диске
2. Несколько видов файловых систем
3. Размещение на разделах различных категорий файлов. Например, системные файлы – на одном разделе, на другом – пользовательские.
4. Ограничение ОС, например на размер диска

## Структура файловой системы

- Ациклический граф с однонаправленными ребрами
- Имя файла связывается не с узлом, соответствующим файлу, а с входящим в него ребром.
- Ребра, выходящие из узлов, соответствующих файлам типа "связь", являются неименованными. 
- В узел "директория" не может входить (обычно) более одного именованного ребра
- Полное имя файла -- имя, получающееся при прохождении по ребрам от корневого узла до узла файла по любому пути, где имена рёбер разделяются символом «/»

![Пример файловой системы](/img/4.png)


## Типы файловых систем
- Extended File System (linux): ext2 (1993+), ext3 (2001+), ext4 (2008+)
- xfs (Silicon Graphics, 1994)
- zfs (Zettabyte File System), Sun, 2005 (поддержка в Linux ограничена)
- ReiserFS (2001), Reiser4 (2004)
- btrfs (B-tree FS, «Better FS»), Oracle, 2008

## Файловая система s5fs
1. Partition делится на:
   - `заголовок раздела`: служебная информация для работы ФС: массив индексных узлов (inodes) с атрибутами файлов, размер фиксирован (65535 шт)
   - `логические блоки`: содержательная часть файлов.
2. Логический блок = `кластер`
   - минимальная адресуемая часть
   - 512 Б – 64киБ, обычно 4кБ
   - формируется из физических `секторов` диска, 512 или 4094 байт
3. `Суперблок` - информация о файловой системы в целом:
   - Тип файловой системы.
   - Флаги состояния файловой системы.
   - Размер логического блока в байтах (обычно кратен 512 байтам).
   - Размер файловой системы в логических блоках (включая сам суперблок и массив inode ). 
   - Размер массива индексных узлов (т.е. сколько файлов может быть размещено в файловой системе).
   - Число свободных индексных узлов (сколько файлов еще можно создать).
   - Число свободных блоков для размещения данных.
   - Часть списка свободных индексных узлов.
   - Часть списка свободных блоков для размещения данных.
4. Индексный узел - index node – inode содержит атрибуты файла:
   - Тип файла и права различных категорий пользователей для доступа к нему.
   - Идентификаторы владельца-пользователя и владельца-группы.
   - Размер файла в байтах (только для регулярных файлов, директорий и файлов типа "связь" ).
   - Время последнего доступа к файлу.
   - Время последней модификации файла.
   - Время последней модификации самого индексного узла.
   - Количество связей у файла
   - `Координаты логических блоков`.
5. `Один inode ↔ один объект ФС`
![Partition](/img/5.png)

## Организация каталогов

1. Объект файловой системы типа directory («директория», каталог):
   - имена файлов, лежащих непосредственно в каталоге + соответствующие номера индексных узлов т.е. (имена ребер, выходящих из узла каталога вместе с индексными номерами узлов, к которым они ведут.)
2. . — сам каталог
3. .. — каталог на уровень выше
4. Имя файла в каталоге:
   - фиксированный размер 14 байт в ФС f5fs
   - переменный размер до 255 байт в современных ФС
5. В зависимости от ФС в каталоге `может` дополнительно храниться длина записи, длина имени файла
![Организация каталогов](/img/6.png)

## Чтение содержимого каталога

```c
#include <sys/types.h>
#include <dirent.h>
// Открывает каталог на чтение, как поток информации
DIR* opendir(char* name); // Возвращаемое значение указатель на хэндл каталога, NULL – ошибка, код ошибки в errno
// name –имя каталога
```

```c
#include <sys/types.h>
#include <dirent.h>
// Читает очередную запись из каталога
struct dirent* readdir(DIR* dir); // Возвращаемое значение данные о записи каталога, NULL – конец каталога

struct dirent {
    char d_name[ ];
    . . . 
};
```

```c
#include <sys/types.h>
#include <dirent.h>
// Позиционирует потока информации для директории на первой записи (начале) директории.
void rewinddir(DIR* dir);
// dir – указатель на открытый каталог

// Закрытие потока информации для директории, очистка внутренних структур.
int closedir(DIR* dir); // Возвращает 0 – успех, -1 – ошибка
// dir – указатель на открытый каталог
```
## Создание жёсткой связи
```bash
$ ln source dest
$ ln src1 src2 .. dest_dir/
```
1. добавляет в каталог запись, указывающую на тот же самый inode исходного файла (файлов)
2. счётчик связей в индексном узле увеличивается
3. объект ФС получает дополнительное имя, `имена равнозначны`
4. невозможно создание жёсткой связи между различными ФС
5. в UNIX (несмотря на стандарт POSIX) запрещено создание жестких связей к каталогам (предотвращаются бесконечные циклы)
6. в Linux запрещено создание жестких связей к специальным файлам устройств

```c
#include <unistd.h>
// Создаёт жёсткую связь
int link(char* pathname, char* linkpathname); // Возвращаемое значение 0 – успех, -1 – ошибка, код ошибки в errno
// pathname –исходное имя файла
// linkpathname – имя создаваемой связи
```

## Создание «мягких» связей

```bash
$ ln –s source dest
$ ln –s src1 src2 .. dest_dir/
```

### Создаёт «мягкие связи»:
1. soft link, symbolic link, мягкая ссылка
2. создаётся специальный файл типа «связь»
3. различаются оригинал и файла-связь
4. возможны ссылки между различными ФС

```c
#include <unistd.h>
// Создаёт мягкую связь
int symlink(char* pathname, char* linkpathname); // Возвращаемое значение 0 – успех, -1 – ошибка, код ошибки в errno
// pathname –исходное имя файла
// linkpathname – имя создаваемой связи
```

## Удаление объектов ФС

```c
#include <unistd.h>
// Удаляет имя объекта ФС, счётчик ссылок файла уменьшается
int unlink(char *pathname); // Возвращаемое значение 0 – успех, -1 – ошибка, код ошибки в errno
// pathname –исходное имя файла
// Если счётчик ссылок =0, то:
//      Если нет процессов, которые открыли файл, то он полностью удаляется (если есть процессы открывшие файл, то продолжает существовать)
//      Если имя относится к файлу типа socket, FIFO или к специальному файлу устройства, то файл удаляется независимо от наличия процессов, держащих его открытым, но процессы, открывшие данный объект, могут продолжать пользоваться им.
//      Если имя относится к файлу типа "связь", то он удаляется, и мягкая связь оказывается разорванной.
```

## Чтение атрибутов файла

```c
#include <sys/stat.h>
#include <unistd.h>

// Читает информацию об атрибутах файла, информацию из индексного узла
int stat(char *filename, struct stat *buf); // Возвращаемое значение 0 – успех, -1 – ошибка, код ошибки в errno
int fstat(int fd, struct stat *buf);
int lstat(char *filename, struct stat *buf);

// filename –имя файла
// fd – файловый дескриптор открытого файла (для fstat)
// buf – указатель на структуру, в которую помещается информация
```


## Чтение атрибутов файла

```c
struct stat {
dev_t st_dev; /* устройство, на котором расположен файл */
ino_t st_ino; /* номер индексного узла для файла */
mode_t st_mode; /* тип файла и права доступа к нему */
nlink_t st_nlink; /* счетчик числа жестких связей */
uid_t st_uid; /* идентификатор пользователя владельца */
gid_t st_gid; /* идентификатор группы владельца */
dev_t st_rdev; /*тип устройства для специальных файлов устройств*/
off_t st_size; /* размер файла в байтах (если определен для данного типа файлов) */
unsigned long st_blksize; /* размер блока для файловой системы */
unsigned long st_blocks;
/* число выделенных блоков */
time_t st_atime, st_mtime, st_ctime; /* время последнего доступа, последней модификации, создания*/
}
```


```c
#include <sys/stat.h>
#include <unistd.h>

struct stat {
    …
    mode_t st_mode;
    …
};
// Макросы для извлечения типа из поля `st_mode`
// S_ISLNK(m) – файл типа "связь"
// S_ISREG(m) – регулярный файл
// S_ISDIR(m) – директория
// S_ISCHR(m) – специальный файл символьного устройства
// S_ISBLK(m) – специальный файл блочного устройства
// S_ISFIFO(m) – файл типа FIFO
// S_ISSOCK(m) – файл типа "socket"
```

## Данные об открытых файлах в ОС

### Информация о файле, необходимая процессу:
- данные, специфичные для этого процесса;
- данные, общие для близко родственных процессов, совместно использующих файл, например, указатель текущей позиции ;
- данные, являющиеся общими для всех процессов, использующих файл, – атрибуты и расположение файла

## Системные вызовы для выполнения операций над файлами

- Создание: creat()
- Открытие/закрытие: open() / close()
- Чтение / запись: read() / write()
- Изменение размера: ftruncate()
- Изменение текущей позиции: lseek()

## Создание файла

```c
#include <fcntl.h>
// Создание пустого файла. Эквивалентно вызову open(path, O_CREAT|O_WRONLY|O_TRUNC, mode). Если файла с указанным именем не существовало, он будет создан и открыт только для записи. Если файл уже существовал, то он открывается также только для записи, при этом его длина уменьшается до 0, другие атрибуты сохраняются. 
int creat(char *path, int mode); //Возвращаемое значение: fd >=0 – файловый дескриптор / -1 – ошибка, расшифровка в errno
// path – путь к файлу
// mode – права доступа
```

## Изменение размера файла

```c
#include <sys/types.h>
#include <unistd.h>
// Изменение длины открытого регулярного (обычного) файла
int ftruncate(
    int fd,       // fd – файловый дескриптор открытого файла
    size_t length // length – нужная длина файла в байтах если меньше текущей длины – файл обрезается, информация теряется; если больше текущей длины – файл дополняется нулевыми байтами до нужного размера
); // Возвращаемое значение: 0 – успех / -1 – ошибка, расшифровка в errno
```

## Изменение текущей позиции

```c
#include <sys/types.h>
#include <unistd.h>
// Изменяет положения указателя текущей позиции в открытом регулярном файле.
off_t lseek(
    int fd,       // fd – файловый дескриптор
    off_t offset, // offset – сдвиг в байтах
    int whence    // whence – откуда считается сдвиг SEEK_SET – от начала / SEEK_CUR – от текущей позиции / SEEK_END – от конца
); // Возвращаемое значение: >=0 – новая текущая позиция относительно начала файла / -1 – ошибка, расшифровка в errno

```


## Файлы отображаемые в память

- `memory mapped` files
- Содержимое файла отображается непосредственно в адресное пространство процесса
- Работа с файлом как с массивом в памяти.
- Используются механизмы виртуальной памяти и страничной организации памяти

## Работа с memory-mapped файлами

1. Открыть файл с помощью обычного системного вызова `open()` . При этом файл отображается в «дисковое пространство».
2. Отобразить файл из «дискового пространства» в «адресное пространство процесса» с помощью системного вызова `mmap()`. Возможно отобразить целиком или частично.
3. После mmap() файл можно закрыть, выполнив системный вызов `close()` , так как необходимая информация о расположении файла на диске уже сохранена в других структурах данных при вызове mmap().
4. После окончания работы с содержимым файла выполнить `munmap()`.


## Отображение файла в память

```c
#include <sys/types.h>
#include <sys/mman.h>
// Отображения предварительно открытого файла в адресное пространство вычислительной системы.
void* mmap(
    void* start,   // start – начало области адресного пространства, в которую будет отображен файл, = NULL, если автоматический режим
    size_t length, // length – размер отображаемой части файла в байтах; length может превышать длину файла, но потом при оступе к отсутствующим данным возникнет сигнал SIGBUS
    int prot, // prot – protection, разрешенные операции над областью памяти, в которую будет отображен файл PROT_READ - разрешено чтение PROT_WRITE - разрешена запись PROT_EXEC – разрешено исполнение PROT_NONE – запрещено всё объединение с помощью "побитовое или" – " | "
    // Значение параметра prot не может быть шире, чем операции над файлом, заявленные при его открытии в параметре flags системного вызова open(). Например, нельзя открыть файл только для чтения, а при его отображении в память использовать значение prot = PROT_READ | PROT_WRITE.
    int flags,     // flags – способ отображения файла в адресное пространство MAP_SHARED – все изменения в памяти доступны другим процессам и сохраняются в файл MAP_PRIVATE – все изменения в памяти доступны только локально, в файл не сохраняются MAP_* - множество других флагов
    int fd,        // fd – файловый дескриптор предварительно открытого файла, который отображаем
    off_t offset   // offset – смещение в байтах от начала файла, начиная с которого отображать содержимое
); // Возвращаемое значение: указатель на начало памяти, куда отображён файл MAP_FAILED (== void*(-1)) – ошибка, расшифровка в errno
```

## Закрытие отображения файла

```c
#include <sys/mman.h>
// Прекращает отображение файла в память и сохраняет изменения в файл (если выставлялись атрибуты PROT_WRITE, MAP_SHARED)
int munmap(
    void *start, // start – адрес начала памяти отображающей файл, который возвращён mmap()
    size_t length // length – длина области памяти, ДОЛЖНА совпадать со значением в mmap().
);  // Возвращаемое значение: 0 – успех -1 – ошибка, расшифровка в errno
```
