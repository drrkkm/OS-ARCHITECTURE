# Процессы в Unix
## Процесс - совокупность
- набора исполняющихся команд
- ассоциированных ресурсов (выделенная память, адресное пространство, стеки, файлы, устройства ввода-вывода и т.д.)
- текущего момента выполнения (значения регистров, прогрманого счетчика, состояния стека, значения переменный и т.д.) 
- под управлением ос

### Все, что выполняется в ОС - процесс.


## Контекс процесса
### Контекст = пользовательский (стек пользователя, динамически выделяемая память, неинециализирумые и инециализируемые изменяемые данные, исполняемый код) + ядерный (стек ядра, данные ядра)

### Контекст ядра - регистровый контекст + системный: стек ядра + данные ядра
### Данные ядра (PCB Process Control Block):
- идентификатор процесса PID
- индентификатор родительского процесса PPID
- идентификатор пользователя UID
- идентификатор группы GID
  
# Иерархия процессов
Каждый процесс пораждается другим
- Создающий процесс - родитель (`parent process`)
- Создаваемый процесс - ребенок, "дочерний процесс" (`child process`)
- Идентификатор процесса в Unix - PID - уникальное чисто 2 ^ 31 - 1

# Команда управления процессами в Linux
## ps
Мгновенный список процессов, запущенных текущим пользователем в текущем терминале
## ps -eF (или ps aux)
Мгновенный список процессов в системе в расширенном формате
## top
Динамический список работающих процессов
## htop
Динамический список процессов с интерфейсом

# Диаграмма состояний процесса
![Диаграмма состояний процесса](/img/d1.png)

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void); // возвращают - 1- ошибка
pid_t getppid(void); // >= 0 в обычном случае (идентификатор родительского процесса)
```

# Создание процесса в Unix
1. Скопировать весь контекст (по методу copy-on-write)
2. Возможно настроить окружение
3. Заменить пользовательский контекст

# Системный вызов создания процесса

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void); // создает копию текущего процесса
// возвращается дважды!  :
//                          в родительском процессе > 0  - PID ребенка / -1 - ошибка
//                            в процессе-ребенке = 0 - успешное порождение
```

# Использование fork()

```c
pid_t pid = fork();
if ( pid > 0 ) {
    // parent
} else if ( pid == 0 ){
    // child
} else {
    // error
}
```

# Завершение процесса

```c
#include <stdlib.h>

void exit(int status);
```
- Нормальнео завершение процесса - закрытие файлов, опустошение буферов, перевод в состояние "закончил исполнение".
- Возврата в программу НЕТ.
- status - код завершения процесса передается ОС (0-255 - допустимые значения, 0 - индикация успешного завершения)
- Если родитель завершается раньше ребенка -> ребенок получает PPID = 1, т.е. родителем становится PID = 1 (головной процесс `init` или `systemd`)
- Если родитель не запрашивает информацию о завершении -> ребенок остается в состоянии "завершил исполнение" = процесс-зомби (zombie, defunct)

# Процесс в представлении C

```c
int main(      // main() - точка входа
    int argc,  // argc - количество слов аргументов в командной строке (argument count)
    char* argv[], // массив слов в "командоной строке" (argument velues)
    char* envp[] // список переменных окружения, строк в виде "var=value"
){
    ...
    return err_code; // из main() -> вызов exit(err)
}
```
```bash
$ ./cmd -o abc 123
# argv[0] argv[1] argv[2] argv[3] / argc == 4
```

# Изменение контекста процесса

```c
#include <unistd.h>
#include <unistd.h>
int execl(const char *path, const char *arg, ..., NULL);
int execlp(const char *file, const char *arg, ..., NULL);
int execle(const char *path, const char *arg, ..., NULL, char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char* const envp[]);
```

- Уничтожает(!) текущий пользовательский контекст и заменяет его на загружаемый из исполняемого файла 
- Возвращает
• -1 – при ошибке
• НЕ возвращается при успехе
- file – имя исполняемого бинарного(!) файла, автопоиск в стандартных
- path – путь к исполняемому бинарному(!) файлу (каталог + имя)



- argv[] – массив аргументов «командной строки» для исполняемой программы, который будет доступен через параметр функции main(…argv[]…)
- arg, …, NULL – перечисление аргументов командной строки, из которых автоматически формируется argv[]
- В обоих случаях, аргументы командной строки должны явно включать 0-ой, который обычно соответствует названию запускаемой программы.

## Использование exec()

```c
#include <unistd.h>

int main(int argc, char* argv[], char* envp[]){
    pid_t p = fork();
    if( p == -1 ){
        perror(“fork”);
        return -1; }
    if( p == 0 ){
        int ret = execle(“/bin/ls”, “ls”, “-l”, NULL, envp);
        if( ret == -1 ) {
            perror(“exec”);
            retrun -2;
        }
    }
    return 0;
}
```